"""
estoque_interface_comentado.py
Sistema de Controle de Estoque com interface Tkinter + JSON.
Cada bloco e linha importante tem coment√°rio explicando o que faz.
Salve no mesmo diret√≥rio onde quiser que o arquivo estoque.json seja criado.
"""

# -----------------------
# 1) IMPORTS (bibliotecas)
# -----------------------
# tkinter: cria a interface gr√°fica (janelas, bot√µes, entradas)
# messagebox: mostra caixas de di√°logo (avisos, erros, info)
# ttk: widgets "themed" (como Treeview para tabela)
# json: salvar/ler os dados em formato JSON
# os: verificar se o arquivo existe
import tkinter as tk
from tkinter import messagebox, ttk
import json
import os

# -----------------------
# 2) CONSTANTE DO ARQUIVO
# -----------------------
# Nome do arquivo onde os produtos ser√£o salvos/recuperados.
# Fica no mesmo diret√≥rio do script por padr√£o.
ARQUIVO = "estoque.json"

# -----------------------------------
# 3) FUN√á√ïES DE ARMAZENAMENTO (I/O)
# -----------------------------------
def carregar_estoque():
    """
    Tenta abrir ARQUIVO e carregar a lista de produtos em JSON.
    Se o arquivo n√£o existir, retorna lista vazia.
    """
    if os.path.exists(ARQUIVO):
        with open(ARQUIVO, "r", encoding="utf-8") as f:
            # json.load converte o texto JSON em objeto Python (lista/dicion√°rios)
            return json.load(f)
    else:
        # Arquivo n√£o existe -> come√ßa com estoque vazio
        return []

def salvar_estoque(estoque):
    """
    Recebe a lista 'estoque' e grava no ARQUIVO em formato JSON.
    indent=4 organiza a sa√≠da para leitura humana.
    ensure_ascii=False preserva caracteres acentuados.
    """
    with open(ARQUIVO, "w", encoding="utf-8") as f:
        json.dump(estoque, f, indent=4, ensure_ascii=False)

# -----------------------------------
# 4) FUN√á√ïES PRINCIPAIS DO SISTEMA
# -----------------------------------
def atualizar_tabela(filtro=""):
    """
    Limpa a tabela e insere os itens do estoque que batem com o filtro.
    O filtro √© comparado com nome e c√≥digo (case-insensitive).
    """
    # Remove todas as linhas da tabela antes de re-popular
    for item in tabela.get_children():
        tabela.delete(item)

    termo = filtro.lower().strip()  # torna busca insens√≠vel a mai√∫sculas/min√∫sculas
    for p in estoque:
        # Se o filtro estiver vazio ou corresponder ao nome/c√≥digo, insere na tabela
        if termo == "" or termo in p["nome"].lower() or termo in p["codigo"].lower():
            # valores exibidos: c√≥digo, nome, quantidade, pre√ßo formatado
            tabela.insert("", tk.END, values=(p["codigo"], p["nome"], p["quantidade"], f"R$ {p['preco']:.2f}"))

def cadastrar_produto():
    """
    L√™ valores dos campos, valida, cria dicion√°rio do produto e salva no estoque.
    Tamb√©m atualiza a tabela e limpa os campos de input.
    """
    codigo = entrada_codigo.get().strip()
    nome = entrada_nome.get().strip()
    quantidade_texto = entrada_quantidade.get().strip()
    preco_texto = entrada_preco.get().strip()

    # Verifica se todos os campos foram preenchidos
    if not codigo or not nome or not quantidade_texto or not preco_texto:
        messagebox.showwarning("Aviso", "Preencha todos os campos!")
        return

    # Verifica se o c√≥digo j√° existe para evitar duplica√ß√£o
    for p in estoque:
        if p["codigo"] == codigo:
            messagebox.showerror("Erro", "C√≥digo j√° cadastrado!")
            return

    # Tenta converter quantidade e pre√ßo para os tipos corretos
    try:
        quantidade = int(quantidade_texto)
        preco = float(preco_texto)
    except ValueError:
        messagebox.showerror("Erro", "Quantidade deve ser inteiro e pre√ßo deve ser n√∫mero (ex: 12.50)!")
        return

    # Cria o dicion√°rio do produto e adiciona √† lista estoque
    produto = {"codigo": codigo, "nome": nome, "quantidade": quantidade, "preco": preco}
    estoque.append(produto)

    # Salva no arquivo e atualiza a tabela visual
    salvar_estoque(estoque)
    atualizar_tabela()
    limpar_campos()
    messagebox.showinfo("Sucesso", "Produto cadastrado com sucesso!")

def entrada_produto():
    """
    Aumenta a quantidade de um produto j√° cadastrado.
    O usu√°rio informa c√≥digo e quantidade.
    """
    codigo = entrada_codigo.get().strip()
    qtd_texto = entrada_quantidade.get().strip()

    if not codigo or not qtd_texto:
        messagebox.showwarning("Aviso", "Informe o c√≥digo e a quantidade!")
        return

    try:
        qtd = int(qtd_texto)
    except ValueError:
        messagebox.showerror("Erro", "Quantidade inv√°lida! Use n√∫mero inteiro.")
        return

    # Procura o produto pelo c√≥digo
    for p in estoque:
        if p["codigo"] == codigo:
            p["quantidade"] += qtd  # adiciona √† quantidade existente
            salvar_estoque(estoque)
            atualizar_tabela()
            messagebox.showinfo("Sucesso", "Entrada registrada!")
            return

    messagebox.showerror("Erro", "Produto n√£o encontrado!")

def saida_produto():
    """
    Diminui a quantidade de um produto j√° cadastrado.
    Verifica se h√° quantidade suficiente antes de subtrair.
    """
    codigo = entrada_codigo.get().strip()
    qtd_texto = entrada_quantidade.get().strip()

    if not codigo or not qtd_texto:
        messagebox.showwarning("Aviso", "Informe o c√≥digo e a quantidade!")
        return

    try:
        qtd = int(qtd_texto)
    except ValueError:
        messagebox.showerror("Erro", "Quantidade inv√°lida! Use n√∫mero inteiro.")
        return

    for p in estoque:
        if p["codigo"] == codigo:
            if p["quantidade"] >= qtd:
                p["quantidade"] -= qtd
                salvar_estoque(estoque)
                atualizar_tabela()
                messagebox.showinfo("Sucesso", "Sa√≠da registrada!")
            else:
                messagebox.showwarning("Aviso", "Quantidade insuficiente no estoque!")
            return

    messagebox.showerror("Erro", "Produto n√£o encontrado!")

def relatorio_baixo_estoque():
    """
    Gera uma lista dos produtos com quantidade abaixo de um limite (aqui padr√£o 5).
    Mostra uma messagebox com os nomes e quantidades.
    """
    limite = 5  # voc√™ pode alterar ou pedir ao usu√°rio antes
    baixo = [p for p in estoque if p["quantidade"] < limite]
    if not baixo:
        messagebox.showinfo("Estoque OK", "Nenhum produto com baixo estoque!")
    else:
        msg = "\n".join([f"{p['nome']} ‚Äî {p['quantidade']} unidades" for p in baixo])
        messagebox.showwarning("Baixo Estoque", msg)

def limpar_campos():
    """
    Limpa os Entry widgets para facilitar novo cadastro/entrada/sa√≠da.
    """
    entrada_codigo.delete(0, tk.END)
    entrada_nome.delete(0, tk.END)
    entrada_quantidade.delete(0, tk.END)
    entrada_preco.delete(0, tk.END)
    # opcional: reposicionar foco no campo c√≥digo
    entrada_codigo.focus()

def buscar_produto(event=None):
    """
    Lido quando o usu√°rio digita no campo de busca.
    Obt√©m o termo e chama atualizar_tabela para filtrar visualmente.
    """
    termo = entrada_busca.get().strip()
    atualizar_tabela(termo)

# -----------------------
# 5) INTERFACE GR√ÅFICA (janela, widgets)
# -----------------------
# Carrega os dados armazenados (se houver) antes de criar a interface
estoque = carregar_estoque()

# Cria a janela principal do Tkinter
janela = tk.Tk()
janela.title("üì¶ Sistema de Controle de Estoque (Comentado)")
# Define tamanho da janela (largura x altura). Ajuste se quiser.
janela.geometry("760x560")
janela.resizable(False, False)  # evita redimensionamento (facilita layout fixo)

# ----- FRAME: busca -----
# Agrupar widgets facilita posicionamento; aqui criamos um frame para a busca
frame_busca = tk.Frame(janela)
frame_busca.pack(pady=8)  # espa√ßamento vertical

# Label explicativo da busca
tk.Label(frame_busca, text="üîé Buscar produto (c√≥digo ou nome):").pack(side=tk.LEFT, padx=5)

# Entrada de texto para busca
entrada_busca = tk.Entry(frame_busca, width=40)
entrada_busca.pack(side=tk.LEFT)
# Bind: toda vez que uma tecla for solta dentro da entrada, chamar buscar_produto
entrada_busca.bind("<KeyRelease>", buscar_produto)

# ----- FRAME: inputs (c√≥digo, nome, qtd, preco) -----
frame_inputs = tk.Frame(janela)
frame_inputs.pack(pady=10)

# Label e Entry para C√≥digo
tk.Label(frame_inputs, text="C√≥digo:").grid(row=0, column=0, padx=5, pady=3, sticky="w")
entrada_codigo = tk.Entry(frame_inputs, width=12)
entrada_codigo.grid(row=0, column=1, pady=3)

# Label e Entry para Nome
tk.Label(frame_inputs, text="Nome:").grid(row=0, column=2, padx=5, pady=3, sticky="w")
entrada_nome = tk.Entry(frame_inputs, width=30)
entrada_nome.grid(row=0, column=3, pady=3)

# Label e Entry para Quantidade
tk.Label(frame_inputs, text="Qtd:").grid(row=1, column=0, padx=5, pady=3, sticky="w")
entrada_quantidade = tk.Entry(frame_inputs, width=12)
entrada_quantidade.grid(row=1, column=1, pady=3)

# Label e Entry para Pre√ßo
tk.Label(frame_inputs, text="Pre√ßo (ex: 12.50):").grid(row=1, column=2, padx=5, pady=3, sticky="w")
entrada_preco = tk.Entry(frame_inputs, width=12)
entrada_preco.grid(row=1, column=3, pady=3)

# ----- FRAME: bot√µes principais -----
frame_botoes = tk.Frame(janela)
frame_botoes.pack(pady=10)

# Bot√£o: Cadastrar produto (chama cadastrar_produto)
btn_cadastrar = tk.Button(frame_botoes, text="Cadastrar Produto", command=cadastrar_produto, width=18)
btn_cadastrar.grid(row=0, column=0, padx=6, pady=3)

# Bot√£o: Entrada de produto (aumenta a quantidade)
btn_entrada = tk.Button(frame_botoes, text="Entrada de Produto", command=entrada_produto, width=18)
btn_entrada.grid(row=0, column=1, padx=6, pady=3)

# Bot√£o: Sa√≠da de produto (diminui a quantidade)
btn_saida = tk.Button(frame_botoes, text="Sa√≠da de Produto", command=saida_produto, width=18)
btn_saida.grid(row=0, column=2, padx=6, pady=3)

# Bot√£o: Relat√≥rio de baixo estoque
btn_relatorio = tk.Button(frame_botoes, text="Relat√≥rio Baixo Estoque", command=relatorio_baixo_estoque, width=18)
btn_relatorio.grid(row=0, column=3, padx=6, pady=3)

# Bot√£o: Limpar campos
btn_limpar = tk.Button(frame_botoes, text="Limpar Campos", command=limpar_campos, width=18)
btn_limpar.grid(row=1, column=1, padx=6, pady=6)

# ----- TABELA (Treeview) para mostrar o estoque -----
# Definimos as colunas: c√≥digo, nome, quantidade e pre√ßo
colunas = ("codigo", "nome", "quantidade", "preco")
tabela = ttk.Treeview(janela, columns=colunas, show="headings", height=15)

# Cabe√ßalhos (texto que aparece na tabela)
tabela.heading("codigo", text="C√≥digo")
tabela.heading("nome", text="Nome")
tabela.heading("quantidade", text="Qtd")
tabela.heading("preco", text="Pre√ßo")

# Largura de colunas e alinhamento
tabela.column("codigo", width=100, anchor="center")
tabela.column("nome", width=340, anchor="w")
tabela.column("quantidade", width=80, anchor="center")
tabela.column("preco", width=100, anchor="center")

# Posiciona a tabela na janela com um padding (espa√ßamento) ao redor
tabela.pack(padx=10, pady=10)

# Atualiza a tabela com os dados carregados do arquivo
atualizar_tabela()

# --------------------------------
# 6) LOOP PRINCIPAL DO TKINTER
# --------------------------------
# Esta linha mant√©m a janela aberta e responde a eventos (cliques, digita√ß√£o, etc.)
janela.mainloop()
